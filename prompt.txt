Add a feature to the pet boarding management system that allows the reservation of kennels to be more flexible. The feature should enable the temporary use of a reserved kennel by another customer if no other kennels are available, with the ability to swap kennels when needed. This will optimize kennel usage and improve the financial efficiency of the business.

**Detailed Instructions:**

1. **Enhance Reservation Logic:**
   - Implement logic to check for available kennels during the desired reservation period.
   - If all kennels are occupied or reserved, identify reserved kennels that can be temporarily made available until their reserved check-in date.

2. **Implement Temporary Reservation Feature:**
   - Allow a new customer to temporarily use a reserved kennel if no other kennels are available.
   - Ensure the system can swap kennels when the original customer arrives.

3. **Drag-and-Drop Functionality:**
   - Enhance the drag-and-drop functionality to support swapping kennel reservations between customers.
   - When swapping, ensure that the correct customer details are retained and updated.

4. **Reservation Form Updates:**
   - Add an option in the reservation form to allow the use of a reserved kennel if necessary.
   - Include a note explaining that the reserved kennel will be available only temporarily and will require a swap when the original customer arrives.

5. **Example Workflow:**
   - **Scenario:**
     - Customer 1 has reserved Kennel 1 from 19/12/2012.
     - Kennel 2 is occupied and will be available on 18/12/2012.
     - Customer 2 wants to reserve a kennel from 16/12/2012 to 19/12/2012.
     - Allow Customer 2 to use Kennel 1 from 16/12/2012 to 18/12/2012.
     - When Customer 1 arrives on 19/12/2012, swap Customer 2 to Kennel 2.

.kennelGrod.jsx :
import React, { useEffect, useState } from "react";
import { supabase } from "../supabase";
import { DragDropContext, Droppable, Draggable } from "react-beautiful-dnd";
import AddKennelsModal from "./AddKennelsModal";
import EditSetsModal from "./EditSetsModal";
import ManageKennelsModal from "./ManageKennelsModal";
import CustomerDetailDialog from "./CustomerDetailDialog";
import { MdEdit } from "react-icons/md";
import { toast, ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import {
  updateKennelStatus,
  updatePetInformation,
  updateReservation,
  updateFeedingSchedule,
} from "./kennelUtils";

const KennelGrid = () => {
  const [kennels, setKennels] = useState([]);
  const [isAddKennelsModalOpen, setIsAddKennelsModalOpen] = useState(false);
  const [isManageKennelsModalOpen, setIsManageKennelsModalOpen] = useState(false);
  const [isEditSetsModalOpen, setIsEditSetsModalOpen] = useState(false);
  const [selectedSet, setSelectedSet] = useState(null);
  const [selectedKennel, setSelectedKennel] = useState(null);
  const [isCustomerDetailDialogOpen, setIsCustomerDetailDialogOpen] = useState(false);

  // Fetch kennels data
  const fetchKennels = async () => {
    try {
      const { data, error } = await supabase
        .from("kennels")
        .select("*")
        .order("created_at", { ascending: true })
        .order("set_name", { ascending: true })
        .order("kennel_number", { ascending: true });

      if (error) {
        throw error;
      } else {
        setKennels(data);
      }
    } catch (error) {
      console.error("Error fetching kennels:", error.message);
    }
  };

  useEffect(() => {
    fetchKennels();

    const subscription = supabase
      .channel("public:kennels")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "kennels" },
        () => {
          fetchKennels();
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(subscription);
    };
  }, []);

  // Open the add kennels modal
  const openAddKennelsModal = () => {
    setIsAddKennelsModalOpen(true);
  };

  // Open the manage kennels modal
  const openManageKennelsModal = () => {
    setIsManageKennelsModalOpen(true);
  };

  // Open the edit sets modal
  const openEditSetsModal = (set) => {
    setSelectedSet(set);
    setIsEditSetsModalOpen(true);
  };

  // Handle kennel click
  const handleKennelClick = (kennel) => {
    if (kennel.status === "occupied" || kennel.status === "reserved") {
      setSelectedKennel(kennel);
      setIsCustomerDetailDialogOpen(true);
    }
  };

  const onDragEnd = async (result) => {
    if (!result.destination) {
      return;
    }

    const sourceId = parseInt(result.source.droppableId);
    const destinationId = parseInt(result.destination.droppableId);

    if (sourceId === destinationId) {
      return;
    }

    const sourceKennel = kennels.find((kennel) => kennel.id === sourceId);
    const destinationKennel = kennels.find(
      (kennel) => kennel.id === destinationId
    );

    if (
      sourceKennel.status === "available" ||
      destinationKennel.status !== "available"
    ) {
      return;
    }

    try {
      await updateKennelStatus(sourceId, destinationId);
      await updatePetInformation(sourceId, destinationId);
      await updateReservation(sourceId, destinationId);
      await updateFeedingSchedule(sourceId, destinationId);

      fetchKennels();
      toast.success(
        `Kennel ${destinationKennel.kennel_number} status changed to ${sourceKennel.status}`
      );
    } catch (error) {
      console.error("Error updating kennel status:", error.message);
      toast.error("Error updating kennel status. Please try again.");
    }
  };

  // Group kennels by set names and sort them
  const groupedKennels = kennels.reduce((acc, kennel) => {
    const setName = kennel.set_name;
    if (!acc[setName]) {
      acc[setName] = [];
    }
    acc[setName].push(kennel);
    return acc;
  }, {});

  // Sort sets by creation order and kennels within each set by number
  const sortedSets = Object.keys(groupedKennels).sort((a, b) => {
    const setA = kennels.find((kennel) => kennel.set_name === a);
    const setB = kennels.find((kennel) => kennel.set_name === b);
    return new Date(setA.created_at) - new Date(setB.created_at);
  });

  return (
    <DragDropContext onDragEnd={onDragEnd}>
      <div className="p-4">
        <ToastContainer
          position="top-right"
          autoClose={2000}
          hideProgressBar={false}
        />
        <h2 className="text-2xl font-semibold mb-4">Kennel Status Overview</h2>
       
        {/* Add Kennels and Manage Kennels Buttons */}
        <div className="flex gap-4 mb-4">
          <button
            className="bg-blue-500 text-white px-4 py-2 rounded-md"
            onClick={openAddKennelsModal}
            title="Click to add new kennels"
          >
            Add Kennels
          </button>
          <button
            className="bg-blue-500 text-white px-4 py-2 rounded-md"
            onClick={openManageKennelsModal}
            title="Click to manage existing kennels"
          >
            Manage Kennels
          </button>
        </div>

        {/* Display Kennels */}
        {sortedSets.map((setName, index) => (
          <div key={index} className="border-b-2 border-gray-200 mb-4 ">
            {/* Set Name */}
            <div className="flex items-center mb-2">
              <h3 className="text-lg mr-1 font-semibold">{setName}</h3>
              {setName !== "Maintenance" && (
                <button
                  onClick={() => openEditSetsModal({ name: setName })}
                  className="text-gray-500 hover:text-gray-700"
                  title="Edit set"
                >
                  <MdEdit />
                </button>
              )}
            </div>

            {/* Kennels in the Set */}
            <div className="grid grid-cols-5 md:grid-cols-10 gap-4 mb-4">
              {groupedKennels[setName].map((kennel) => (
                <Droppable
                  key={kennel.id}
                  droppableId={kennel.id.toString()}
                  isDropDisabled={kennel.status !== "available" || setName === "Maintenance"}
                >
                  {(provided, snapshot) => (
                    <div
                      ref={provided.innerRef}
                      {...provided.droppableProps}
                      className={`p-4 text-center rounded-md transition-colors ${
                        snapshot.isDraggingOver
                          ? "bg-blue-200"
                          : setName === "Maintenance"
                          ? "bg-gray-400 text-white"
                          : kennel.status === "available"
                          ? "bg-green-500 text-white"
                          : kennel.status === "reserved"
                          ? "bg-yellow-500 text-white cursor-pointer"
                          : kennel.status === "occupied"
                          ? "bg-red-500 text-white cursor-pointer"
                          : "bg-gray-400 text-white"
                      }`}
                      style={{
                        transition: "background-color 0.3s ease",
                        cursor:
                          kennel.status === "reserved" ||
                          kennel.status === "occupied"
                            ? "pointer"
                            : "default",
                      }}
                      onClick={() =>
                        (kennel.status === "reserved" ||
                          kennel.status === "occupied") &&
                        handleKennelClick(kennel)
                      }
                    >
                      <Draggable
                        draggableId={kennel.id.toString()}
                        index={kennel.kennel_number}
                        isDragDisabled={kennel.status === "available" || setName === "Maintenance"}
                      >
                        {(provided, snapshot) => (
                          <div
                            ref={provided.innerRef}
                            {...provided.draggableProps}
                            {...provided.dragHandleProps}
                            style={{
                              ...provided.draggableProps.style,
                              cursor:
                                kennel.status === "available" ||
                                setName === "Maintenance"
                                  ? "default"
                                  : "grab",
                              background: snapshot.isDragging
                                ? "rgba(0,0,0,0.1)"
                                : "inherit",
                              borderRadius: "8px",
                              padding: "8px",
                              boxShadow: snapshot.isDragging
                                ? "0 4px 8px rgba(0, 0, 0, 0.2)"
                                : "none",
                            }}
                          >
                            {kennel.status !== "available" ? (
                              <div>Kennel {kennel.kennel_number}</div>
                            ) : (
                              `Kennel ${kennel.kennel_number}`
                            )}
                          </div>
                        )}
                      </Draggable>
                      {provided.placeholder}
                    </div>
                  )}
                </Droppable>
              ))}
            </div>
          </div>
        ))}

        {/* Add Kennels Modal */}
        {isAddKennelsModalOpen && (
          <AddKennelsModal
            isOpen={isAddKennelsModalOpen}
            onClose={() => setIsAddKennelsModalOpen(false)}
          />
        )}

        {/* Manage Kennels Modal */}
        {isManageKennelsModalOpen && (
          <ManageKennelsModal
            isOpen={isManageKennelsModalOpen}
            onClose={() => setIsManageKennelsModalOpen(false)}
          />
        )}

        {/* Edit Sets Modal */}
        {isEditSetsModalOpen && (
          <EditSetsModal
            isOpen={isEditSetsModalOpen}
            onClose={() => setIsEditSetsModalOpen(false)}
            setToEdit={selectedSet}
          />
        )}

        {/* Customer Detail Dialog */}
        {isCustomerDetailDialogOpen && (
          <CustomerDetailDialog
            isOpen={isCustomerDetailDialogOpen}
            onClose={() => setIsCustomerDetailDialogOpen(false)}
            customer={selectedKennel}
          />
        )}
         {/* Legend */}
         <div className="flex gap-4 mb-4">
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 bg-green-500 rounded"></div>
            <span>Available</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 bg-yellow-500 rounded"></div>
            <span>Reserved</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 bg-red-500 rounded"></div>
            <span>Occupied</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 bg-gray-400 rounded"></div>
            <span>Maintenance</span>
          </div>
        </div>
      </div>
    </DragDropContext>
  );
};

export default KennelGrid;
,
kennelUtils.js :
import { supabase } from "../supabase";

export const updateKennelStatus = async (sourceId, destinationId) => {
  const { data: sourceKennel, error: sourceError } = await supabase
    .from("kennels")
    .select("status")
    .eq("id", sourceId)
    .single();

  if (sourceError) throw sourceError;

  const { error: updateSourceError } = await supabase
    .from("kennels")
    .update({ status: "available" })
    .eq("id", sourceId);

  if (updateSourceError) throw updateSourceError;

  const { error: updateDestinationError } = await supabase
    .from("kennels")
    .update({ status: sourceKennel.status })
    .eq("id", destinationId);

  if (updateDestinationError) throw updateDestinationError;
};

export const updatePetInformation = async (sourceId, destinationId) => {
  const { error: updateError } = await supabase
    .from("pet_information")
    .update({ kennel_id: destinationId })
    .eq("kennel_id", sourceId);

  if (updateError) throw updateError;
};

export const updateReservation = async (sourceId, destinationId) => {
  const { data: reservations, error: fetchError } = await supabase
    .from("reservations")
    .select("id, kennel_ids, kennel_numbers")
    .contains("kennel_ids", [sourceId]);

  if (fetchError) throw fetchError;

  for (const reservation of reservations) {
    const updatedKennelIds = reservation.kennel_ids.map(id =>
      id === sourceId ? destinationId : id
    );

    const updatedKennelNumbers = { ...reservation.kennel_numbers };
    updatedKennelNumbers[destinationId] = updatedKennelNumbers[sourceId];
    delete updatedKennelNumbers[sourceId];

    const { error: updateError } = await supabase
      .from("reservations")
      .update({
        kennel_ids: updatedKennelIds,
        kennel_numbers: updatedKennelNumbers,
      })
      .eq("id", reservation.id);

    if (updateError) throw updateError;
  }
};

export const updateFeedingSchedule = async (sourceId, destinationId) => {
  const { error: updateError } = await supabase
    .from("feeding_schedule")
    .update({ kennel_id: destinationId })
    .eq("kennel_id", sourceId);

  if (updateError) throw updateError;
};
,
ReservationForm.jsx :
import React, { useState, useEffect } from "react";
import DatePicker from "react-datepicker";
import "react-datepicker/dist/react-datepicker.css";
import { useForm, Controller } from "react-hook-form";
import { supabase } from "../supabase";
import { FaCalendarAlt } from "react-icons/fa";
import { Switch } from "@headlessui/react";
import { toast, ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";

const petBreeds = [
  "Affenpinscher",

  "Šarplaninac",
];

const ReservationForm = () => {
  const {
    register,
    handleSubmit,
    control,
    reset,
    setValue,
    watch,
    formState: { errors },
  } = useForm();
  const [availableKennels, setAvailableKennels] = useState([]);
  const [selectedKennels, setSelectedKennels] = useState([]);
  const [pets, setPets] = useState([]);
  const [currentPet, setCurrentPet] = useState({
    name: "",
    breed: "",
    pickup: false,
    groom: false,
    drop: false,
  });
  const [isPetDialogOpen, setIsPetDialogOpen] = useState(false);
  const [currentKennel, setCurrentKennel] = useState(null);
  const [filteredBreeds, setFilteredBreeds] = useState([]);
  const [showBreedOptions, setShowBreedOptions] = useState(false);

  const startDate = watch("startDate");

  const fetchCustomerDetails = async (phone) => {
    const { data, error } = await supabase
      .from("customers")
      .select("customer_name, customer_address")
      .eq("customer_phone", phone)
      .single();

    if (error) {
      console.error("Error fetching customer details:", error.message);
      return null;
    }

    return data;
  };

  const handleCustomerPhoneChange = async (e) => {
    const phone = e.target.value;
    setValue("customerPhone", phone);

    if (phone.trim() !== "") {
      const customerData = await fetchCustomerDetails(phone);
      if (customerData) {
        setValue("customerName", customerData.customer_name);
        setValue("customerAddress", customerData.customer_address);
      } else {
        if (!watch("customerName").trim() && !watch("customerAddress").trim()) {
          setValue("customerName", "");
          setValue("customerAddress", "");
        }
      }
    } else {
      setValue("customerName", "");
      setValue("customerAddress", "");
    }
  };

  const fetchAvailableKennels = async () => {
    const { data, error } = await supabase
      .from("kennels")
      .select("*")
      .eq("status", "available")
      .neq("set_name", "Maintenance")
      .order("created_at", { ascending: true });

    if (error) {
      console.error("Error fetching kennels:", error.message);
    } else {
      setAvailableKennels(data);
    }
  };

  const createReservation = async (data) => {
    if (validateForm(data)) {
      let customerData;

      const { data: existingCustomers, error: fetchCustomerError } =
        await supabase
          .from("customers")
          .select("*")
          .eq("customer_phone", data.customerPhone);

      if (fetchCustomerError) {
        console.error("Error fetching customer:", fetchCustomerError.message);
        return;
      }

      if (existingCustomers.length > 0) {
        customerData = existingCustomers[0];
      } else {
        const { data: newCustomer, error: newCustomerError } = await supabase
          .from("customers")
          .insert([
            {
              customer_name: data.customerName,
              customer_phone: data.customerPhone,
              customer_address: data.customerAddress,
            },
          ])
          .select();

        if (newCustomerError) {
          console.error("Error creating customer:", newCustomerError.message);
          return;
        }

        customerData = newCustomer[0];
      }

      const reservationStatus =
        data.endDate < new Date() ? "checked_out" : "pending";

      for (const pet of pets) {
        const { error: reservationError } = await supabase
          .from("reservations")
          .insert({
            customer_id: customerData.id,
            pet_name: pet.name,
            pet_breed: pet.breed,
            start_date: data.startDate,
            end_date: data.endDate,
            status: reservationStatus,
            kennel_ids: [pet.kennel.id],
            pickup: pet.pickup,
            groom: pet.groom,
            drop: pet.drop,
          });

        if (reservationError) {
          console.error(
            "Error creating reservation:",
            reservationError.message
          );
        } else {
          const kennelStatus =
            reservationStatus === "checked_out" ? "available" : "reserved";
          await supabase
            .from("kennels")
            .update({ status: kennelStatus })
            .eq("id", pet.kennel.id);
        }
      }

      toast.success("Reservation created successfully!");
      clearForm();
    }
  };

  const validateForm = (data) => {
    const newErrors = {};
    let isValid = true;

    if (!data.customerName) {
      newErrors.customerName = "Please enter the customer name";
      isValid = false;
    }

    if (!data.customerPhone) {
      newErrors.customerPhone = "Please enter the customer phone number";
      isValid = false;
    }

    if (!data.customerAddress) {
      newErrors.customerAddress = "Please enter the customer address";
      isValid = false;
    }

    if (!data.startDate) {
      newErrors.startDate = "Please select Check In date";
      isValid = false;
    }

    if (!data.endDate) {
      newErrors.endDate = "Please select Check Out date";
      isValid = false;
    }

    if (selectedKennels.length === 0) {
      newErrors.selectedKennels = "Please select at least one kennel";
      isValid = false;
    }

    setValue("errors", newErrors);
    return isValid;
  };

  const handleKennelSelection = (kennel) => {
    const existingPet = pets.find((pet) => pet.kennel.id === kennel.id);
    if (existingPet) {
      setCurrentPet(existingPet);
    } else {
      setCurrentPet({
        name: "",
        breed: "",
        pickup: false,
        groom: false,
        drop: false,
      });
    }
    setCurrentKennel(kennel);
    setIsPetDialogOpen(true);
  };

  const handlePetDialogSave = () => {
    if (currentPet.name && currentPet.breed) {
      const updatedPets = pets.filter(
        (pet) => pet.kennel.id !== currentKennel.id
      );
      setPets([...updatedPets, { ...currentPet, kennel: currentKennel }]);
      setSelectedKennels([...selectedKennels, currentKennel]);
      setIsPetDialogOpen(false);
    }
  };

  const handleBreedInputChange = (e) => {
    const breed = e.target.value;
    setCurrentPet({ ...currentPet, breed });

    if (breed.trim() !== "") {
      const filtered = petBreeds.filter((b) =>
        b.toLowerCase().includes(breed.toLowerCase())
      );
      setFilteredBreeds(filtered);
      setShowBreedOptions(true);
    } else {
      setFilteredBreeds([]);
      setShowBreedOptions(false);
    }
  };

  const handleBreedSelect = (breed) => {
    setCurrentPet({ ...currentPet, breed });
    setShowBreedOptions(false);
  };

  const clearForm = () => {
    reset();
    setSelectedKennels([]);
    setPets([]);
  };

  useEffect(() => {
    if (startDate) {
      fetchAvailableKennels();
    }
  }, [startDate]);

  return (
    <div className="max-w-screen-xl mx-auto p-6 bg-white">
      <ToastContainer
        position="top-right"
        autoClose={3000}
        hideProgressBar={false}
      />
      <h2 className="text-2xl font-bold mb-6 text-center">
        Create Reservation
      </h2>
      <form onSubmit={handleSubmit(createReservation)}>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
          <div>
            <div className="mb-4">
              <label
                htmlFor="customerName"
                className="block text-sm font-medium text-gray-700"
              >
                Customer Name
              </label>
              <input
                type="text"
                id="customerName"
                className={`w-full p-3 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                  errors.customerName ? "border-red-500" : "border-gray-300"
                }`}
                {...register("customerName", {
                  required: "Please enter the customer name",
                })}
              />
              {errors.customerName && (
                <p className="text-red-500 text-sm mt-1">
                  {errors.customerName.message}
                </p>
              )}
            </div>

            <div className="mb-4">
              <label
                htmlFor="customerPhone"
                className="block text-sm font-medium text-gray-700"
              >
                Customer Phone
              </label>
              <input
                type="text"
                id="customerPhone"
                className={`w-full p-3 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                  errors.customerPhone ? "border-red-500" : "border-gray-300"
                }`}
                {...register("customerPhone", {
                  required: "Please enter the customer phone number",
                })}
                onChange={handleCustomerPhoneChange}
              />
              {errors.customerPhone && (
                <p className="text-red-500 text-sm mt-1">
                  {errors.customerPhone.message}
                </p>
              )}
            </div>

            <div className="mb-4">
              <label
                htmlFor="customerAddress"
                className="block text-sm font-medium text-gray-700"
              >
                Customer Address
              </label>
              <input
                type="text"
                id="customerAddress"
                className={`w-full p-3 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                  errors.customerAddress ? "border-red-500" : "border-gray-300"
                }`}
                {...register("customerAddress", {
                  required: "Please enter the customer address",
                })}
              />
              {errors.customerAddress && (
                <p className="text-red-500 text-sm mt-1">
                  {errors.customerAddress.message}
                </p>
              )}
            </div>
          </div>

          <div>
            <div className="mb-4">
              <label
                htmlFor="startDate"
                className="block text-sm font-medium text-gray-700"
              >
                Check In
              </label>
              <div className="relative">
                <Controller
                  control={control}
                  name="startDate"
                  render={({ field }) => (
                    <DatePicker
                      id="startDate"
                      selected={field.value}
                      onChange={(date) => field.onChange(date)}
                      className={`w-full p-3 pl-10 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                        errors.startDate ? "border-red-500" : "border-gray-300"
                      }`}
                      dateFormat="yyyy/MM/dd"
                      placeholderText="Select a start date"
                      minDate={new Date()}
                    />
                  )}
                />
                <FaCalendarAlt className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500" />
              </div>
              {errors.startDate && (
                <p className="text-red-500 text-sm mt-1">
                  {errors.startDate.message}
                </p>
              )}
            </div>

            <div className="mb-4">
              <label
                htmlFor="endDate"
                className="block text-sm font-medium text-gray-700"
              >
                Check Out
              </label>
              <div className="relative">
                <Controller
                  control={control}
                  name="endDate"
                  render={({ field }) => (
                    <DatePicker
                      id="endDate"
                      selected={field.value}
                      onChange={(date) => field.onChange(date)}
                      className={`w-full p-3 pl-10 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 ${
                        errors.endDate ? "border-red-500" : "border-gray-300"
                      }`}
                      dateFormat="yyyy/MM/dd"
                      placeholderText="Select an end date"
                      minDate={startDate}
                    />
                  )}
                />
                <FaCalendarAlt className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500" />
              </div>
              {errors.endDate && (
                <p className="text-red-500 text-sm mt-1">
                  {errors.endDate.message}
                </p>
              )}
            </div>
          </div>
        </div>

        {startDate && (
          <div className="mt-8">
            <h3 className="text-lg font-semibold mb-4">Select Kennels</h3>
            {availableKennels.length === 0 && (
              <p className="text-gray-500">No kennels available</p>
            )}
            {availableKennels.length > 0 &&
              availableKennels
                .reduce((acc, kennel) => {
                  const setIndex = acc.findIndex(
                    (item) => item.name === kennel.set_name
                  );
                  if (setIndex === -1) {
                    acc.push({ name: kennel.set_name, kennels: [kennel] });
                  } else {
                    acc[setIndex].kennels.push(kennel);
                  }
                  return acc;
                }, [])
                .map((set) => (
                  <div key={set.name} className="mb-6">
                    <h4 className="text-lg font-semibold mb-2">{set.name}</h4>
                    <div className="grid grid-cols-8 gap-6 ">
                      {set.kennels
                        .sort(
                          (a, b) => a.kennel_number - b.kennel_number
                        )
                        .map((kennel) => (
                          <div
                            key={kennel.id}
                            className={`p-4 text-center rounded-md cursor-pointer transition-all aspect-square ${
                              selectedKennels.includes(kennel)
                                ? "bg-blue-500 text-white"
                                : "bg-gray-200 hover:bg-gray-300"
                            }`}
                            onClick={() => handleKennelSelection(kennel)}
                          >
                            Kennel {kennel.kennel_number}
                          </div>
                        ))}
                    </div>
                  </div>
                ))}
            {errors.selectedKennels && (
              <p className="text-red-500 text-sm mt-1">
                {errors.selectedKennels.message}
              </p>
            )}
          </div>
        )}

        <div className="flex justify-center space-x-4 mt-8">
          <button
            type="button"
            className="px-6 py-3 rounded-md bg-gray-300 text-gray-700 hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400"
            onClick={clearForm}
          >
            Clear Form
          </button>

          <button
            type="submit"
            className="px-6 py-3 rounded-md bg-blue-500 text-white hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            Create Reservation
          </button>
        </div>
      </form>

      {isPetDialogOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center">
          <div className="bg-white p-6 w-2/6 rounded-lg shadow-lg">
            <h3 className="text-lg font-bold mb-4">Enter Pet Details</h3>
            <div className="mb-4">
              <label
                htmlFor="petName"
                className="block text-sm font-medium text-gray-700"
              >
                Pet Name
              </label>
              <input
                type="text"
                id="petName"
                className="w-full p-3 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                value={currentPet.name}
                onChange={(e) =>
                  setCurrentPet({ ...currentPet, name: e.target.value })
                }
              />
            </div>
            <div className="mb-4 relative">
              <label
                htmlFor="petBreed"
                className="block text-sm font-medium text-gray-700"
              >
                Pet Breed
              </label>
              <input
                type="text"
                id="petBreed"
                className="w-full p-3 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                value={currentPet.breed}
                onChange={handleBreedInputChange}
                onFocus={() => setShowBreedOptions(true)}
                onBlur={() => setTimeout(() => setShowBreedOptions(false), 200)}
              />
              {showBreedOptions && (
                <ul className="absolute z-10 w-full mt-1 bg-white border rounded-md border-gray-300 shadow-lg">
                  {filteredBreeds.map((breed, index) => (
                    <li
                      key={index}
                      className="px-3 py-2 cursor-pointer text-sm hover:bg-gray-100"
                      onClick={() => handleBreedSelect(breed)}
                    >
                      {breed}
                    </li>
                  ))}
                </ul>
              )}
            </div>
            <div className="mb-4">
              <legend className="text-lg font-medium text-gray-900 mb-2">
                Services
              </legend>
              <div className="space-y-2">
                <Switch.Group>
                  <div className="flex items-center justify-between">
                    <Switch.Label className="mr-4">Pickup</Switch.Label>
                    <Switch
                      checked={currentPet.pickup}
                      onChange={(value) =>
                        setCurrentPet({ ...currentPet, pickup: value })
                      }
                      className={`${
                        currentPet.pickup ? "bg-blue-600" : "bg-gray-200"
                      } relative inline-flex h-6 w-11 items-center rounded-full`}
                    >
                      <span
                        className={`${
                          currentPet.pickup ? "translate-x-6" : "translate-x-1"
                        } inline-block h-4 w-4 transform bg-white rounded-full transition`}
                      />
                    </Switch>
                  </div>
                </Switch.Group>
                <Switch.Group>
                  <div className="flex items-center justify-between">
                    <Switch.Label className="mr-4">Groom</Switch.Label>
                    <Switch
                      checked={currentPet.groom}
                      onChange={(value) =>
                        setCurrentPet({ ...currentPet, groom: value })
                      }
                      className={`${
                        currentPet.groom ? "bg-blue-600" : "bg-gray-200"
                      } relative inline-flex h-6 w-11 items-center rounded-full`}
                    >
                      <span
                        className={`${
                          currentPet.groom ? "translate-x-6" : "translate-x-1"
                        } inline-block h-4 w-4 transform bg-white rounded-full transition`}
                      />
                    </Switch>
                  </div>
                </Switch.Group>
                <Switch.Group>
                  <div className="flex items-center justify-between">
                    <Switch.Label className="mr-4">Drop</Switch.Label>
                    <Switch
                      checked={currentPet.drop}
                      onChange={(value) =>
                        setCurrentPet({ ...currentPet, drop: value })
                      }
                      className={`${
                        currentPet.drop ? "bg-blue-600" : "bg-gray-200"
                      } relative inline-flex h-6 w-11 items-center rounded-full`}
                    >
                      <span
                        className={`${
                          currentPet.drop ? "translate-x-6" : "translate-x-1"
                        } inline-block h-4 w-4 transform bg-white rounded-full transition`}
                      />
                    </Switch>
                  </div>
                </Switch.Group>
              </div>
            </div>
            <div className="flex justify-end space-x-4">
              <button
                type="button"
                className="px-4 py-2 rounded-md bg-gray-300 text-gray-700 hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400"
                onClick={() => setIsPetDialogOpen(false)}
              >
                Cancel
              </button>
              <button
                type="button"
                className="px-4 py-2 rounded-md bg-blue-500 text-white hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                onClick={handlePetDialogSave}
              >
                Save
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ReservationForm;
. supabase tables:
create table
  public.customers (
    id serial,
    customer_name character varying(255) not null,
    customer_phone character varying(15) not null,
    customer_address character varying(255) not null,
    created_at timestamp without time zone null default current_timestamp,
    constraint customers_pkey primary key (id),
    constraint customers_customer_phone_key unique (customer_phone)
  ) tablespace pg_default;
  ,
  create table
  public.kennels (
    id serial,
    kennel_number integer not null,
    status character varying(20) not null default 'available'::character varying,
    set_name character varying(255) null default 'Maintenance'::character varying,
    updated_at timestamp without time zone not null default now(),
    created_at timestamp without time zone null default now(),
    constraint kennels_pkey primary key (id)
  ) tablespace pg_default;
  ,
  create table
  public.pet_information (
    id serial,
    kennel_id integer null,
    reservation_id integer null,
    dietary_requirements text null,
    special_care_instructions text null,
    medical_notes text null,
    created_at timestamp without time zone null default current_timestamp,
    updated_at timestamp without time zone null default current_timestamp,
    constraint pet_information_pkey primary key (id),
    constraint pet_information_kennel_id_fkey foreign key (kennel_id) references kennels (id),
    constraint pet_information_reservation_id_fkey foreign key (reservation_id) references reservations (id)
  ) tablespace pg_default;
  ,
  create table
  public.reservations (
    id serial,
    pet_name character varying(255) not null,
    pet_breed character varying(255) not null,
    start_date date not null,
    end_date date not null,
    status character varying(20) null default 'pending'::character varying,
    kennel_ids integer[] null,
    pickup boolean null default false,
    groom boolean null default false,
    drop boolean null default false,
    created_at timestamp without time zone null default current_timestamp,
    customer_id integer not null,
    kennel_numbers jsonb null,
    constraint reservations_pkey primary key (id),
    constraint reservations_customer_id_fkey foreign key (customer_id) references customers (id)
  ) tablespace pg_default;
  ,
  create table
  public.feeding_schedule (
    id serial,
    kennel_id integer null,
    feeding_date date null,
    feeding_time character varying(10) null,
    fed boolean null,
    eaten boolean null,
    created_at timestamp without time zone null default current_timestamp,
    constraint feeding_schedule_pkey primary key (id),
    constraint feeding_schedule_unique unique (kennel_id, feeding_date, feeding_time),
    constraint feeding_schedule_kennel_id_fkey foreign key (kennel_id) references kennels (id)
  ) tablespace pg_default;

, can you suggest an method on how to do this or if is it possible ?  do you know how other hotels manage reservations for such cases .don't provide code now , i will ask for it later.

 SOLUTIONS :
 I believe a simplified version of the flexible reservation system would work best for your Pet Boarding Management System. Since you only have one side that employees use, we can focus on creating a system that gives your staff the tools they need to manage reservations efficiently while maximizing kennel usage. Here's a tailored approach for your specific case:

1. Enhanced Reservation System:
   - Implement a "Flexible Reservation" option in your existing reservation form.
   - When making a new reservation, first check for fully available kennels.
   - If no kennels are available for the entire duration, look for kennels that are partially available (i.e., available for at least part of the requested period).

2. Kennel Assignment Logic:
   - Assign the pet to the available kennel for the duration it's free.
   - For the period where the original kennel is not available, flag the reservation as needing reassignment.

3. Kennel Reassignment Dashboard:
   - Create a new view in your KennelGrid component that shows reservations needing reassignment.
   - This dashboard should display:
     - The pet's name
     - Current assigned kennel
     - Dates needing reassignment
     - Available kennels for those dates

4. Manual Reassignment Process:
   - Allow staff to manually reassign kennels using drag-and-drop functionality in the KennelGrid.
   - When a staff member reassigns a kennel, update the reservation in the database.

5. Notification System:
   - Implement a simple notification system within the application to alert staff about reservations that need reassignment.
   - This could be a counter on the dashboard showing the number of reservations needing attention.

6. Database Modifications:
   - Add a 'flexible_reservation' boolean field to your reservations table.
   - Add a 'needs_reassignment' boolean field to your reservations table.
   - Add a 'reassignment_date' date field to your reservations table.


This system maintains the simplicity needed for a staff-only interface while providing the flexibility to maximize kennel usage. It doesn't require complex algorithms for automatic reassignment, which could be challenging to implement and maintain. Instead, it relies on your staff's judgement for kennel reassignments, which can be beneficial as they may have additional context about specific pets or customers.

The manual reassignment process also allows for easier handling of special cases, such as if a customer has specific kennel preferences or if certain pets need to be kept separate.
,
Here's a summary of the key components we need to implement or modify:
ReservationForm.jsx:
Add a "Flexible Reservation" option
Implement logic to check for partially available kennels
KennelGrid.jsx:
Add a new section for "Reservations Needing Reassignment"
Implement drag-and-drop functionality for kennel reassignment
kennelUtils.js:
Add functions to handle flexible reservations and reassignments
Database modifications:
Add 'flexible_reservation', 'needs_reassignment', and 'reassignment_date' fields to the reservations table
New components:
ReassignmentDashboard.jsx: To display reservations needing reassignment
NotificationSystem.jsx: To alert staff about reservations needing attention
